<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FS • Чистая вода будущего</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <!-- ===== Шапка ===== -->
  <header class="topbar">
    <div class="logo">FS</div>
    <nav>
      <a href="#">О проекте</a>
      <a href="#about">Почему это важно</a>
      <a href="#tech">Как мы очищаем воду</a>
    </nav>
  </header>

  <main>
    <!-- ===== HERO со счётчиком ===== -->
    <section class="hero">
      <div class="capsule">
        <div id="odo" class="odo" aria-live="polite"></div>
      </div>
      <h1 class="subtitle">
        Именно столько тысяч пластиковых бутылок выбрасывается в России, пока вы здесь
      </h1>
    </section>

    <!-- ===== ПОЧЕМУ ЭТО ВАЖНО (падающие бутылки) ===== -->
    <section class="why" id="about" aria-labelledby="why-title">
      <canvas id="bottleCanvas" aria-hidden="true"></canvas>
      <h2 id="why-title">Почему это важно</h2>
      <p>
        Каждую секунду — тысячи пластиковых бутылок, которые никогда не исчезнут.
        FS создаёт системы, которые очищают воду и уменьшают количество отходов,
        возвращая природе то, что ей принадлежит. Мы верим, что будущее —
        это не борьба с природой, а забота о ней.
      </p>
    </section>

    <!-- ===== КАК МЫ ОЧИЩАЕМ ВОДУ ===== -->
    <section class="tech" id="tech" aria-labelledby="tech-title">
      <h2 id="tech-title">Как мы очищаем воду</h2>
      <p class="lead">
        Поток проходит через три ступени: грубая механическая фильтрация,
        угольный сорбционный модуль и тонкая мембрана. На выходе — чистая вода.
      </p>

      <div class="pipeline">
        <svg class="pipe-svg" viewBox="0 0 1200 220" preserveAspectRatio="xMidYMid meet">
          <defs>
            <linearGradient id="tubeGrad" x1="0" x2="1" y1="0" y2="0">
              <stop offset="0" stop-color="#eaf1ff"/>
              <stop offset="1" stop-color="#dbe7ff"/>
            </linearGradient>
            <linearGradient id="waterGrad" x1="0" x2="1" y1="0" y2="0">
              <stop offset="0" stop-color="#2b8cff"/>
              <stop offset="1" stop-color="#1047a8"/>
            </linearGradient>
          </defs>

          <path id="tube"
                d="M 40 110 H 360
                   C 410 110, 410 40, 460 40
                   H 600
                   C 650 40, 650 180, 700 180
                   H 860
                   C 910 180, 910 110, 960 110
                   H 1160"
                fill="none" stroke="url(#tubeGrad)" stroke-width="36"
                stroke-linecap="round" stroke-linejoin="round" />

          <path id="flow"
                d="M 40 110 H 360
                   C 410 110, 410 40, 460 40
                   H 600
                   C 650 40, 650 180, 700 180
                   H 860
                   C 910 180, 910 110, 960 110
                   H 1160"
                fill="none" stroke="url(#waterGrad)" stroke-width="16"
                stroke-linecap="round" stroke-linejoin="round"
                stroke-dasharray="80 420" />

          <g class="tick" transform="translate(360,110)">
            <circle r="8" fill="#1047a8"/>
          </g>
          <g class="tick" transform="translate(600,40)">
            <circle r="8" fill="#1047a8"/>
          </g>
          <g class="tick" transform="translate(860,180)">
            <circle r="8" fill="#1047a8"/>
          </g>
        </svg>

        <ul class="stages" aria-label="Этапы очистки">
          <li class="stage">
            <h3>Грубая</h3>
            <p>Сетчатый фильтр задерживает песок, ржавчину и крупные частицы.</p>
          </li>
          <li class="stage">
            <h3>Сорбция</h3>
            <p>Активированный уголь удаляет хлор, запахи и органические примеси.</p>
          </li>
          <li class="stage">
            <h3>Мембрана</h3>
            <p>Тонкая мембрана удерживает микро-загрязнения и бактерии.</p>
          </li>
        </ul>
      </div>
    </section>
  </main>

  <!-- ===== Счётчик ===== -->
  <script>
  (function(){
    const BPS=6000, DIGITS=6, odo=document.getElementById('odo');
    function makeDigit(){const d=document.createElement('div');d.className='digit';const s=document.createElement('div');s.className='strip';
      for(let k=0;k<10;k++){const c=document.createElement('div');c.className='cell';c.textContent=k;s.appendChild(c)}
      const e=document.createElement('div');e.className='cell';e.textContent='0';s.appendChild(e);d.appendChild(s);return d}
    function build(){odo.innerHTML='';for(let i=0;i<DIGITS;i++) odo.appendChild(makeDigit())}
    build();
    let cellH=0; function measure(){const s=odo.querySelector('.cell'); if(s) cellH=Math.round(s.getBoundingClientRect().height)}
    measure(); addEventListener('resize',()=>{measure(); setNumber(cur)});
    let prev=new Array(DIGITS).fill(0), start=performance.now(), cur=0;
    function setNumber(n){const str=Math.max(0,Math.floor(n)).toString().padStart(DIGITS,'0'); const strips=odo.querySelectorAll('.digit .strip');
      for(let i=0;i<DIGITS;i++){const st=strips[i]; const c=+str[i]; if(c!==prev[i]){st.parentElement.classList.add('anim'); st.style.transform='translate3d(0,'+(-cellH*c)+'px,0)'}}
      prev=str.split('').map(Number)
    }
    function frame(now){const t=(now-start)/1000; cur=(BPS*t)/1000; const stepped=Math.floor(cur*10)/10; setNumber(stepped); requestAnimationFrame(frame)}
    requestAnimationFrame(frame);
  })();
  </script>

  <!-- ===== Падающие бутылки ===== -->
  <script>
  (function(){
    const section = document.getElementById('about');
    const canvas  = document.getElementById('bottleCanvas');
    const ctx     = canvas.getContext('2d');

    let W=0,H=0, dpr=1;
    let bottles=[], running=false, rafId=0, spawnTimer=0;

    function resize(){
      const r = section.getBoundingClientRect();
      dpr = Math.min(window.devicePixelRatio||1, 2);
      W = Math.max(1, Math.floor(r.width));
      H = Math.max(1, Math.floor(r.height));
      canvas.width  = Math.floor(W*dpr);
      canvas.height = Math.floor(H*dpr);
      canvas.style.width = W+'px';
      canvas.style.height= H+'px';
      canvas.style.position='absolute';
      canvas.style.inset='0';
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    resize();
    addEventListener('resize', resize, {passive:true});

    function drawBottle(x,y,w,h,angle,alpha=1){
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.translate(x,y);
      ctx.rotate(angle);
      const r = Math.min(w,h)/6;
      ctx.fillStyle = '#3a7cff';
      ctx.beginPath(); ctx.roundRect(-w/2, -h/2, w, h, r); ctx.fill();
      ctx.fillStyle = '#1e4fb3';
      ctx.beginPath(); ctx.roundRect(-w*0.18, -h*0.58, w*0.36, h*0.12, r*0.4); ctx.fill();
      ctx.fillStyle = 'rgba(255,255,255,.22)';
      ctx.beginPath(); ctx.roundRect(-w*0.32, -h*0.35, w*0.16, h*0.55, r*0.6); ctx.fill();
      ctx.restore();
    }

    class Bottle {
      constructor(x){
        this.w = 28 + Math.random()*16;
        this.h = this.w*2.1;
        this.x = x;
        this.y = -this.h;
        this.vy = 1.2 + Math.random()*1.6;
        this.ang = Math.random()*Math.PI;
        this.vang= (Math.random()*0.6-0.3)*0.02;
        this.drift = (Math.random()*0.6-0.3)*0.25;
        this.settled = false;
        this.alpha = 0;
      }
      update(){
        if(!this.settled){
          this.y += this.vy;
          this.x += this.drift;
          this.ang += this.vang;
          this.alpha = Math.min(1, this.alpha+0.06);
          if(this.y >= H - this.h*0.5){
            this.y = H - this.h*0.5;
            this.settled = true;
          }
        } else this.ang += this.vang*0.2;
      }
      draw(){ drawBottle(this.x, this.y, this.w, this.h, this.ang, this.alpha); }
    }

    function isFilled(){
      const area = W*H;
      const avg = (40*80);
      const target = Math.max(12, Math.floor(area / (avg*6)));
      return bottles.filter(b=>b.settled).length >= target;
    }

    function tick(){
      ctx.clearRect(0,0,W,H);
      if(!isFilled()){
        spawnTimer -= 1;
        if(spawnTimer<=0){
          spawnTimer = 3;
          bottles.push(new Bottle(Math.random()*W));
        }
      }
      for(let i=0;i<bottles.length;i++){
        const b=bottles[i]; b.update(); b.draw();
        if(b.y>H+200){ bottles.splice(i,1); i--; }
      }
      if(running) rafId=requestAnimationFrame(tick);
    }
    function start(){ if(running)return; running=true; bottles=[]; spawnTimer=0; rafId=requestAnimationFrame(tick);}
    function stop(){ running=false; cancelAnimationFrame(rafId); ctx.clearRect(0,0,W,H); bottles=[]; }

    const io=new IntersectionObserver(entries=>{
      entries.forEach(e=>{
        if(e.isIntersecting) start(); else stop();
      });
    },{threshold:0.25});
    io.observe(section);
  })();
  </script>

  <!-- ===== Анимация потока воды и карточек ===== -->
  <script>
  (function(){
    const sec=document.getElementById('tech');
    const io=new IntersectionObserver(entries=>{
      entries.forEach(e=>{
        if(e.isIntersecting) sec.classList.add('play');
        else sec.classList.remove('play');
      });
    },{threshold:.35});
    io.observe(sec);
  })();
  </script>
</body>
</html>
