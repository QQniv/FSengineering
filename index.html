<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FS • Счётчик пластиковых бутылок</title>
  <style>
    :root{
      --bg:#2b8cff;
      --capsule:#ffffff;
      --ink:#222831;
      --text:#0a1f33;
      --shadow:rgba(0,0,0,.15);
    }
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%}
    body{
      font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:var(--bg); color:var(--ink);
    }

    /* Header */
    .topbar{
      position:sticky; top:0; z-index:20; height:80px;
      display:flex; align-items:center; justify-content:space-between;
      padding:0 8vw; color:#fff;
      background:rgba(255,255,255,.05); backdrop-filter:blur(20px);
      transition:background .3s ease;
    }
    .topbar.scrolled{ background:rgba(10,31,51,.25) }
    .logo{
      font-family:Impact, Haettenschweiler, 'Arial Black', sans-serif;
      font-size:54px; letter-spacing:1px; color:#fff;
    }
    .nav a{
      color:#fff; text-decoration:none; margin-left:40px;
      font-weight:600; font-size:16px; opacity:.9;
    }
    .nav a:hover{ opacity:1 }

    /* Hero / Counter */
    .hero{
      min-height:calc(100vh - 80px);
      display:grid; place-items:center; gap:28px; padding:24px 0 40px;
    }
    .capsule{
      background:var(--capsule); border-radius:999px;
      width:min(1000px,85vw); height:min(55vh,420px);
      display:flex; align-items:center; justify-content:center;
      box-shadow:0 25px 80px var(--shadow), inset 0 0 10px rgba(255,255,255,.3);
    }
    .odo{ display:flex; gap:8px; align-items:center }
    .digit{ position:relative; width:clamp(50px,7vw,90px); height:clamp(90px,15vw,160px); overflow:hidden; border-radius:12px }
    .strip{ position:absolute; inset:0; display:flex; flex-direction:column; will-change:transform }
    .cell{
      height:100%; display:flex; align-items:center; justify-content:center;
      font-family:Impact, Haettenschweiler, 'Arial Black', sans-serif;
      font-weight:900; font-size:clamp(60px,13vw,150px); color:var(--ink);
    }
    .digit.anim .strip{ transition:transform .45s cubic-bezier(.25,.8,.25,1) }

    .subtitle{
      color:#fff; max-width:800px;
      font-family:Impact, Haettenschweiler, 'Arial Black', sans-serif;
      font-size:clamp(18px,2.4vw,26px); line-height:1.4; text-align:center; padding:0 16px;
    }

    /* Why section with canvas scene */
    .why{
      position:relative; background:#fff; color:var(--text);
      padding:120px 8vw; display:flex; flex-direction:column; align-items:center; text-align:center; gap:40px; overflow:hidden;
    }
    .scene{ position:absolute; inset:0; z-index:0; opacity:.25; pointer-events:none }
    #scene{ width:100%; height:100%; display:block }
    .why h2{
      position:relative; z-index:1;
      font-family:Impact, Haettenschweiler, 'Arial Black', sans-serif;
      font-size:clamp(36px,5vw,72px); line-height:1.1; letter-spacing:-.02em; max-width:900px;
    }
    .why p{
      position:relative; z-index:1;
      max-width:720px; font-size:clamp(18px,2vw,22px); line-height:1.6; color:#30455c; margin:0 auto 16px;
    }

    /* Reveal */
    .reveal{ opacity:0; transform:translateY(40px); transition:opacity .8s ease, transform .8s ease }
    .reveal.visible{ opacity:1; transform:translateY(0) }
  </style>
</head>
<body>
  <header id="topbar" class="topbar">
    <div class="logo">FS</div>
    <nav class="nav">
      <a href="#about">О проекте</a>
      <a href="#tech">Технологии</a>
      <a href="#contact">Контакты</a>
    </nav>
  </header>

  <main>
    <section class="hero" id="home" aria-labelledby="counter-title">
      <div class="capsule" role="group" aria-live="polite" aria-label="Счётчик выброшенных бутылок в тысячах">
        <div id="odo" class="odo"></div>
      </div>
      <h1 id="counter-title" class="subtitle">
        Именно столько тысяч пластиковых бутылок выбрасывается в России, пока вы здесь
      </h1>
    </section>

    <section class="why" id="about">
      <div class="scene" aria-hidden="true">
        <canvas id="scene"></canvas>
      </div>
      <h2 class="reveal">Почему это важно</h2>
      <p class="reveal">
        Каждую секунду — тысячи пластиковых бутылок, которые никогда не исчезнут. 
        FS создаёт системы, которые очищают воду и уменьшают количество отходов, 
        возвращая природе то, что ей принадлежит. Мы верим, что будущее — это не борьба с природой, а забота о ней.
      </p>
    </section>
  </main>

  <!-- Scripts -->
  <script>
    // Sticky header
    const header = document.getElementById('topbar');
    window.addEventListener('scroll', () => {
      header.classList.toggle('scrolled', window.scrollY > 30);
    });

    // Counter (thousands)
    (function(){
      const BPS = 6000;        // бутылок в секунду
      const DIGITS = 6;        // 6 разрядов: считаем в тысячах
      const odo = document.getElementById('odo');

      function makeDigit(){
        const d = document.createElement('div'); d.className='digit';
        const s = document.createElement('div'); s.className='strip';
        for(let k=0;k<10;k++){ const c=document.createElement('div'); c.className='cell'; c.textContent=k; s.appendChild(c); }
        const e = document.createElement('div'); e.className='cell'; e.textContent='0'; s.appendChild(e);
        d.appendChild(s); return d;
      }
      function build(){ odo.innerHTML=''; for(let i=0;i<DIGITS;i++) odo.appendChild(makeDigit()); }
      build();

      let cellH=0;
      function measure(){ const s=odo.querySelector('.cell'); if(s){ cellH=Math.round(s.getBoundingClientRect().height);} }
      measure(); addEventListener('resize', ()=>{ measure(); setNumber(count); });

      let count=300000, prev=new Array(DIGITS).fill(0);
      function setNumber(n){
        const str = Math.max(0,Math.floor(n)).toString().padStart(DIGITS,'0');
        const strips = odo.querySelectorAll('.digit .strip');
        for(let i=0;i<DIGITS;i++){
          const st=strips[i]; const cur=+str[i];
          if(cur!==prev[i]){
            st.parentElement.classList.add('anim');
            st.style.transform='translate3d(0,'+(-cellH*cur)+'px,0)';
          }
        }
        prev = str.split('').map(Number);
      }

      setNumber(count);
      let acc=0,last=performance.now();
      function loop(now){
        const dt=(now-last)/1000; last=now;
        acc += (BPS*dt)/1000;      // переводим в «тысячи»
        while(acc>=0.1){ acc-=0.1; count+=0.1; setNumber(count); }
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);
    })();

    // Reveal
    const reveals = document.querySelectorAll('.reveal');
    const io = new IntersectionObserver((entries)=>{
      entries.forEach(e=>{ if(e.isIntersecting) e.target.classList.add('visible'); });
    },{threshold:.2});
    reveals.forEach(el=>io.observe(el));

    // === Реалистичная анимация силуэта на canvas ===
    (function () {
      const cvs = document.getElementById("scene");
      if (!cvs) return;
      const ctx = cvs.getContext("2d");
      let dpr = Math.max(1, window.devicePixelRatio || 1);

      function resize() {
        const r = cvs.getBoundingClientRect();
        cvs.width = Math.max(2, Math.floor(r.width * dpr));
        cvs.height = Math.max(2, Math.floor(r.height * dpr));
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
      resize();
      addEventListener("resize", resize);

      // utils
      const TAU = Math.PI * 2;
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const mix = (a, b, t) => a + (b - a) * t;
      const easeInOut = (t) => (t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2);
      const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);
      const rand = (a,b)=>a+Math.random()*(b-a);

      // бутылка
      const drawBottle = (x, y, rot = 0, scale=1, alpha=1) => {
        ctx.save(); ctx.translate(x, y); ctx.rotate(rot); ctx.scale(scale, scale); ctx.globalAlpha = alpha;
        // тень
        ctx.fillStyle = "rgba(0,0,0,0.12)";
        ctx.beginPath(); ctx.ellipse(0, 32, 18, 6, 0, 0, TAU); ctx.fill();
        // тело
        ctx.fillStyle = "#2b8cff"; ctx.strokeStyle = "#1a58cc"; ctx.lineWidth = 1.2;
        const bw = 26, bh = 64, r = 10;
        ctx.beginPath();
        ctx.moveTo(-bw/2+r, -bh/2);
        ctx.lineTo(bw/2-r, -bh/2);
        ctx.quadraticCurveTo(bw/2, -bh/2, bw/2, -bh/2+r);
        ctx.lineTo(bw/2, bh/2-r);
        ctx.quadraticCurveTo(bw/2, bh/2, bw/2-r, bh/2);
        ctx.lineTo(-bw/2+r, bh/2);
        ctx.quadraticCurveTo(-bw/2, bh/2, -bw/2, bh/2-r);
        ctx.lineTo(-bw/2, -bh/2+r);
        ctx.quadraticCurveTo(-bw/2, -bh/2, -bw/2+r, -bh/2);
        ctx.closePath(); ctx.fill(); ctx.stroke();
        ctx.fillStyle = "#1047a8"; ctx.fillRect(-8, -bh/2-8, 16, 10);
        ctx.restore();
      };

      // «живой» объект бутылки в текущем цикле
      const bottle = {
        active:false, x:0, y:0, vx:0, vy:0, rot:0, rotVel:0,
      };

      // мусор на полу
      const TRASH_LIMIT = 120;
      const trash = []; // {x,y,rot,scale,alpha,fading}

      function addTrash(x,y,rot,scale){
        trash.push({x,y,rot,scale,alpha:1,fading:false});
        // если перебор — запускаем растворение у самых старых
        while(trash.length > TRASH_LIMIT){
          const oldest = trash[0];
          oldest.fading = true;
          // если уже прозрачный — удаляем
          if(oldest.alpha <= 0){ trash.shift(); }
          else break;
        }
      }

      function drawTrash(){
        for(let i=0;i<trash.length;i++){
          const t = trash[i];
          if(t.fading){ t.alpha -= 0.01; if(t.alpha<=0){ trash.splice(i,1); i--; continue; } }
          drawBottle(t.x, t.y, t.rot, t.scale, t.alpha);
        }
      }

      // Силуэт
      class Actor {
        constructor() {
          this.h = 520;                    // базовая высота
          this.w = this.h * 0.32;          // чуть уже для более HUMAN пропорций
          this.angles = {
            hipL: 0, hipR: 0, kneeL: 0, kneeR: 0,
            armL: 0, armR: 0, elbowL: 0, elbowR: 0,
            head: 0, bodyTilt: 0, shoulderTilt:0, pelvisTilt:0,
            ankleL:0, ankleR:0
          };
        }
        draw(ctx, x, yBase, scale = 1, flip=false) {
          const H = this.h * scale, W = this.w * scale;
          const yHip = yBase - H * 0.57, yShoulder = yBase - H * 0.80, yNeck = yBase - H * 0.84, yHead = yBase - H * 0.96;

          ctx.save();
          if(flip){ ctx.translate(x + W, 0); ctx.scale(-1,1); x = 0; } // зеркалим при движении справа-налево
          const cx = x + W * 0.50;

          // тень пола
          ctx.fillStyle = "rgba(0,0,0,0.12)";
          ctx.beginPath(); ctx.ellipse(cx, yBase - 6, 90 * scale, 12 * scale, 0, 0, TAU); ctx.fill();

          // плечи/таз — легкая контрфаза
          const shTilt = this.angles.shoulderTilt;
          const pvTilt = this.angles.pelvisTilt;

          // таз
          ctx.save(); ctx.translate(cx, yHip); ctx.rotate(pvTilt);
          ctx.fillStyle = "#0b1e33";
          ctx.beginPath();
          ctx.ellipse(0, 0, W*0.16, H*0.035, 0, 0, TAU);
          ctx.fill();
          ctx.restore();

          // торс
          ctx.save(); ctx.translate(cx, (yHip + yShoulder)/2); ctx.rotate(this.angles.bodyTilt);
          ctx.beginPath();
          ctx.moveTo(-W*0.14, (yHip - (yHip + yShoulder)/2));
          ctx.quadraticCurveTo(-W*0.18, (yShoulder - (yHip + yShoulder)/2), -W*0.06, (yNeck - (yHip + yShoulder)/2));
          ctx.lineTo(W*0.06, (yNeck - (yHip + yShoulder)/2));
          ctx.quadraticCurveTo(W*0.18, (yShoulder - (yHip + yShoulder)/2), W*0.14, (yHip - (yHip + yShoulder)/2));
          ctx.closePath();
          ctx.fill();
          ctx.restore();

          // шея + голова
          ctx.fillStyle = "#0b1e33";
          ctx.save(); ctx.translate(cx, yNeck); ctx.rotate(this.angles.head);
          ctx.fillRect(-W*0.03, -H*0.015, W*0.06, H*0.03); // шея
          ctx.beginPath(); ctx.ellipse(0, -H*0.045, W * 0.11, W * 0.14, 0, 0, TAU); ctx.fill(); // голова (овальнее)
          ctx.restore();

          // НОГИ (с перекатом стопы)
          const drawLeg = (side, hipA, kneeA, ankleA) => {
            const dir = side === "L" ? -1 : 1;
            const hipX = cx + dir * W * 0.11;

            const kneeX = hipX + Math.sin(hipA) * W * 0.22;
            const kneeY = yHip + Math.cos(hipA) * H * 0.22;

            const ankleX = kneeX + Math.sin(kneeA) * W * 0.24;
            const ankleY = kneeY + Math.cos(kneeA) * H * 0.24;

            // бедро
            ctx.beginPath();
            ctx.moveTo(hipX - dir * W * 0.04, yHip);
            ctx.lineTo(kneeX - dir * W * 0.025, kneeY);
            ctx.lineTo(kneeX + dir * W * 0.025, kneeY);
            ctx.lineTo(hipX + dir * W * 0.04, yHip);
            ctx.closePath(); ctx.fill();

            // голень
            ctx.beginPath();
            ctx.moveTo(kneeX - dir * W * 0.025, kneeY);
            ctx.lineTo(ankleX - dir * W * 0.02, ankleY);
            ctx.lineTo(ankleX + dir * W * 0.02, ankleY);
            ctx.lineTo(kneeX + dir * W * 0.025, kneeY);
            ctx.closePath(); ctx.fill();

            // стопа (перекат)
            ctx.save(); ctx.translate(ankleX, ankleY); ctx.rotate(ankleA);
            ctx.beginPath();
            ctx.moveTo(-W*0.07, 0);
            ctx.lineTo(W*0.08, 0);
            ctx.quadraticCurveTo(W*0.10, H*0.012, W*0.05, H*0.018);
            ctx.lineTo(-W*0.09, H*0.018);
            ctx.quadraticCurveTo(-W*0.11, H*0.010, -W*0.07, 0);
            ctx.closePath(); ctx.fill();
            ctx.restore();
          };
          drawLeg("L", this.angles.hipL, this.angles.kneeL, this.angles.ankleL);
          drawLeg("R", this.angles.hipR, this.angles.kneeR, this.angles.ankleR);

          // РУКИ
          const drawArm = (side, shoulderA, elbowA, hasBottle = false) => {
            const dir = side === "L" ? -1 : 1;
            const shX = cx + dir * W * 0.12, shY = yShoulder;

            // плечо (с учётом наклона плеч)
            const shoulderRot = shoulderA + shTilt*dir*0.3;
            const elbowX = shX + Math.sin(shoulderRot) * W * 0.26;
            const elbowY = shY + Math.cos(shoulderRot) * H * 0.22;

            const foreRot = elbowA;
            const handX = elbowX + Math.sin(foreRot) * W * 0.24;
            const handY = elbowY + Math.cos(foreRot) * H * 0.24;

            // плечо
            ctx.beginPath();
            ctx.moveTo(shX - dir * W * 0.025, shY);
            ctx.lineTo(elbowX - dir * W * 0.02, elbowY);
            ctx.lineTo(elbowX + dir * W * 0.02, elbowY);
            ctx.lineTo(shX + dir * W * 0.025, shY);
            ctx.closePath(); ctx.fill();

            // предплечье
            ctx.beginPath();
            ctx.moveTo(elbowX - dir * W * 0.02, elbowY);
            ctx.lineTo(handX - dir * W * 0.02, handY);
            ctx.lineTo(handX + dir * W * 0.02, handY);
            ctx.lineTo(elbowX + dir * W * 0.02, elbowY);
            ctx.closePath(); ctx.fill();

            // кисть (кружком)
            ctx.beginPath(); ctx.ellipse(handX, handY, W*0.018, W*0.018, 0, 0, TAU); ctx.fill();

            if (hasBottle) drawBottle(handX, handY, -0.12*(flip?-1:1), 1, 1);
            return {handX, handY};
          };

          // правая рука с бутылкой
          this.handR = drawArm("R", this.angles.armR, this.angles.elbowR, true);
          // левая рука
          drawArm("L", this.angles.armL, this.angles.elbowL, false);

          ctx.restore();
        }
      }

      const actor = new Actor();

      // состояние цикла
      let playing = false, startT = 0, cycle = 0, dirLeftToRight = true;

      function startCycle(){
        // чередуем направление
        dirLeftToRight = (cycle % 2 === 0);
        cycle++;
        // «живая» бутылка заново
        bottle.active = false; bottle.vx = bottle.vy = 0; bottle.rotVel = 0; bottle.rot = 0;
        startT = performance.now();
        playing = true;
        requestAnimationFrame(draw);
      }
      function stop(){ playing = false; }

      function draw(now) {
        const w = cvs.clientWidth || cvs.width / dpr;
        const h = cvs.clientHeight || cvs.height / dpr;
        const yBase = h * 0.95;
        ctx.clearRect(0, 0, w, h);

        // фон пола
        const g = ctx.createLinearGradient(0, yBase-80, 0, yBase+20);
        g.addColorStop(0, "rgba(10,31,51,0.03)");
        g.addColorStop(1, "rgba(10,31,51,0)");
        ctx.fillStyle = g;
        ctx.fillRect(0, yBase-80, w, 100);

        // TRASH
        drawTrash();

        const T = 8;
        const t = clamp((now - startT) / 1000, 0, T);

        // направление и траектория X
        const leftToRight = dirLeftToRight;
        const xEnter = leftToRight ? -0.2*w : 1.2*w;
        const xMid   = leftToRight ? mix(-0.2*w, 1.2*w, 0.35) : mix(1.2*w, -0.2*w, 0.35);
        const xExit  = leftToRight ? 1.2*w : -0.2*w;
        let x;
        if (t < 2) x = mix(xEnter, xMid, easeOutCubic(t/2));
        else if (t < 5) x = xMid;
        else x = mix(xMid, xExit, (t - 5) / 3);

        // походка и позы
        const step = Math.sin(t * TAU * 0.75) * 5.5;
        const scale = clamp(h / actor.h * 0.9, 0.55, 1);
        const yMan = yBase - actor.h * scale + step;

        const walkPhase = (leftToRight ? 1 : -1) * Math.sin(t * TAU * 0.75);
        actor.angles.hipL = walkPhase * 0.28;
        actor.angles.kneeL = actor.angles.hipL + 0.65;
        actor.angles.hipR = -actor.angles.hipL;
        actor.angles.kneeR = actor.angles.hipR + 0.65;

        // перекат стоп
        actor.angles.ankleL = -walkPhase * 0.15;
        actor.angles.ankleR = walkPhase * 0.15;

        // контрфаза плеч/таза
        actor.angles.pelvisTilt = walkPhase * 0.05;
        actor.angles.bodyTilt = walkPhase * 0.04;
        actor.angles.shoulderTilt = -walkPhase * 0.06;

        // руки
        actor.angles.armL = -actor.angles.hipL * 0.60;
        actor.angles.elbowL = actor.angles.armL + 0.85;

        if (t < 2.2){ actor.angles.armR = 0.1; actor.angles.elbowR = 0.95; actor.angles.head = 0; }
        else if (t < 3.4){ const k = easeInOut((t-2.2)/1.2); actor.angles.armR = mix(0.1,-1.05,k); actor.angles.elbowR = mix(0.95,1.75,k); actor.angles.head = mix(0,-0.22,k); }
        else if (t < 4.2){ const k=(t-3.4)/0.8; actor.angles.armR = -1.05 + Math.sin(k*TAU)*0.05; actor.angles.elbowR = 1.75 + Math.sin(k*TAU)*0.03; actor.angles.head = -0.22; }
        else if (t < 5){ const k = easeOutCubic((t-4.2)/0.8); actor.angles.armR = mix(-1.05,0.25,k); actor.angles.elbowR = mix(1.75,0.85,k); actor.angles.head = mix(-0.22,0,k); }
        else { actor.angles.armR = 0.25; actor.angles.elbowR = 0.85; actor.angles.head = 0; }

        // силуэт
        actor.draw(ctx, x, yBase, scale, !leftToRight);

        // у рта
        const mouthX = x + actor.w * scale * (leftToRight ? 0.46 : 0.54);
        const mouthY = yMan + actor.h * scale * 0.35;

        // ----- бутылка (одна!) -----
        if (!bottle.active) {
          // в руке — до 4.2с
          if (t <= 4.2) {
            const holdK = t < 2.2 ? 0 : (t < 3.4 ? easeInOut((t - 2.2)/1.2) : 1);
            const bx0 = x + actor.w * scale * (leftToRight ? 0.56 : 0.44);
            const by0 = yMan + actor.h * scale * 0.70;
            const bx = mix(bx0, mouthX, holdK);
            const by = mix(by0, mouthY, holdK);
            drawBottle(bx, by, -0.12*(leftToRight?1:-1), 1, 1);
          } else {
            // отпускаем — инициализируем физику
            bottle.active = true;
            bottle.x = mouthX;
            bottle.y = mouthY;
            bottle.vx = (leftToRight ? 90 : -90) * 0.6;   // начальный дрейф
            bottle.vy = -120;                              // небольшой подброс
            bottle.rot = -0.25*(leftToRight?1:-1);
            bottle.rotVel = (leftToRight?1:-1) * 2.0;
          }
        } else {
          // физика полёта и столкновения
          const dt = 1/60;
          bottle.vy += 1400 * dt;             // гравитация
          bottle.x += bottle.vx * dt;
          bottle.y += bottle.vy * dt;
          bottle.rot += bottle.rotVel * dt;

          if (bottle.y > yBase - 14) {
            // приземление
            bottle.y = yBase - 14;
            // добавляем в мусор и выключаем «живую» бутылку
            addTrash(
              bottle.x + rand(-6,6), bottle.y,
              bottle.rot + rand(-0.1,0.1),
              0.9 + Math.random()*0.2
            );
            bottle.active = false;
          } else {
            drawBottle(bottle.x, bottle.y, bottle.rot, 1, 1);
          }
        }

        if (t < T && playing) {
          requestAnimationFrame(draw);
        } else if (t >= T && playing && !bottle.active) {
          // цикл завершён, запускаем следующий при видимости
          playing = false;
        }
      }

      // запуск/остановка по видимости
      const sec = document.querySelector(".why");
      const ioScene = new IntersectionObserver((ents) => {
        ents.forEach(e => {
          if(e.isIntersecting){
            if(!playing) startCycle();
          } else {
            stop();
          }
        });
      },{threshold:.35});
      ioScene.observe(sec);
    })();
  </script>
</body>
</html>
