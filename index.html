<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FS • Счётчик пластиковых бутылок</title>
  <style>
    :root{
      --bg:#2b8cff;
      --capsule:#ffffff;
      --ink:#222831;
      --text:#0a1f33;
      --shadow:rgba(0,0,0,.15);

      /* Палитра силуэта */
      --skin:#0b1e33;          /* кожа/силуэт */
      --shirt-top:#2657b8;     /* футболка верх (градиент) */
      --shirt-bot:#1e3a6f;     /* футболка низ (градиент) */
      --pants:#0e2140;         /* штаны тёмные */

      /* Бутылка */
      --bottle:#2b8cff;
      --bottle-cap:#1047a8;
      --bottle-stroke:#1a58cc;
    }
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%}
    body{
      font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:var(--bg); color:var(--ink);
    }

    /* Header */
    .topbar{
      position:sticky; top:0; z-index:20; height:80px;
      display:flex; align-items:center; justify-content:space-between;
      padding:0 8vw; color:#fff;
      background:rgba(255,255,255,.05); backdrop-filter:blur(20px);
      transition:background .3s ease;
    }
    .topbar.scrolled{ background:rgba(10,31,51,.25) }
    .logo{
      font-family:Impact, Haettenschweiler, 'Arial Black', sans-serif;
      font-size:54px; letter-spacing:1px; color:#fff;
    }
    .nav a{
      color:#fff; text-decoration:none; margin-left:40px;
      font-weight:600; font-size:16px; opacity:.9;
    }
    .nav a:hover{ opacity:1 }

    /* Hero / Counter */
    .hero{
      min-height:calc(100vh - 80px);
      display:grid; place-items:center; gap:28px; padding:24px 0 40px;
    }
    .capsule{
      background:var(--capsule); border-radius:999px;
      width:min(1000px,85vw); height:min(55vh,420px);
      display:flex; align-items:center; justify-content:center;
      box-shadow:0 25px 80px var(--shadow), inset 0 0 10px rgba(255,255,255,.3);
    }
    .odo{ display:flex; gap:8px; align-items:center }
    .digit{ position:relative; width:clamp(50px,7vw,90px); height:clamp(90px,15vw,160px); overflow:hidden; border-radius:12px }
    .strip{ position:absolute; inset:0; display:flex; flex-direction:column; will-change:transform }
    .cell{
      height:100%; display:flex; align-items:center; justify-content:center;
      font-family:Impact, Haettenschweiler, 'Arial Black', sans-serif;
      font-weight:900; font-size:clamp(60px,13vw,150px); color:var(--ink);
    }
    .digit.anim .strip{ transition:transform .45s cubic-bezier(.25,.8,.25,1) }

    .subtitle{
      color:#fff; max-width:800px;
      font-family:Impact, Haettenschweiler, 'Arial Black', sans-serif;
      font-size:clamp(18px,2.4vw,26px); line-height:1.4; text-align:center; padding:0 16px;
    }

    /* Why section with canvas scene */
    .why{
      position:relative; background:#fff; color:var(--text);
      padding:120px 8vw; display:flex; flex-direction:column; align-items:center; text-align:center; gap:40px; overflow:hidden;
    }
    .scene{ position:absolute; inset:0; z-index:0; pointer-events:none }
    #scene{ width:100%; height:100%; display:block }
    .why h2{
      position:relative; z-index:1;
      font-family:Impact, Haettenschweiler, 'Arial Black', sans-serif;
      font-size:clamp(36px,5vw,72px); line-height:1.1; letter-spacing:-.02em; max-width:900px;
    }
    .why p{
      position:relative; z-index:1;
      max-width:720px; font-size:clamp(18px,2vw,22px); line-height:1.6; color:#30455c; margin:0 auto 16px;
    }

    /* Reveal */
    .reveal{ opacity:0; transform:translateY(40px); transition:opacity .8s ease, transform .8s ease }
    .reveal.visible{ opacity:1; transform:translateY(0) }
  </style>
</head>
<body>
  <header id="topbar" class="topbar">
    <div class="logo">FS</div>
    <nav class="nav">
      <a href="#about">О проекте</a>
      <a href="#tech">Технологии</a>
      <a href="#contact">Контакты</a>
    </nav>
  </header>

  <main>
    <section class="hero" id="home" aria-labelledby="counter-title">
      <div class="capsule" role="group" aria-live="polite" aria-label="Счётчик выброшенных бутылок в тысячах">
        <div id="odo" class="odo"></div>
      </div>
      <h1 id="counter-title" class="subtitle">
        Именно столько тысяч пластиковых бутылок выбрасывается в России, пока вы здесь
      </h1>
    </section>

    <section class="why" id="about">
      <div class="scene" aria-hidden="true">
        <canvas id="scene"></canvas>
      </div>
      <h2 class="reveal">Почему это важно</h2>
      <p class="reveal">
        Каждую секунду — тысячи пластиковых бутылок, которые никогда не исчезнут. 
        FS создаёт системы, которые очищают воду и уменьшают количество отходов, 
        возвращая природе то, что ей принадлежит. Мы верим, что будущее — это не борьба с природой, а забота о ней.
      </p>
    </section>
  </main>

  <!-- Scripts -->
  <script>
    // Sticky header
    const header = document.getElementById('topbar');
    window.addEventListener('scroll', () => {
      header.classList.toggle('scrolled', window.scrollY > 30);
    });

    // Counter (тысячи) — сбрасывается при перезагрузке
    (function(){
      const BPS = 6000, DIGITS = 6, odo = document.getElementById('odo');
      function makeDigit(){ const d=document.createElement('div'); d.className='digit'; const s=document.createElement('div'); s.className='strip';
        for(let k=0;k<10;k++){ const c=document.createElement('div'); c.className='cell'; c.textContent=k; s.appendChild(c);} const e=document.createElement('div'); e.className='cell'; e.textContent='0'; s.appendChild(e); d.appendChild(s); return d;}
      function build(){ odo.innerHTML=''; for(let i=0;i<DIGITS;i++) odo.appendChild(makeDigit()); }
      build();
      let cellH=0; function measure(){ const s=odo.querySelector('.cell'); if(s) cellH=Math.round(s.getBoundingClientRect().height); }
      measure(); addEventListener('resize', ()=>{ measure(); setNumber(currentThousands); });
      let prev = new Array(DIGITS).fill(0), start = performance.now(), currentThousands = 0;
      function setNumber(n){ const str=Math.max(0,Math.floor(n)).toString().padStart(DIGITS,'0'); const strips=odo.querySelectorAll('.digit .strip');
        for(let i=0;i<DIGITS;i++){ const st=strips[i]; const cur=+str[i]; if(cur!==prev[i]){ st.parentElement.classList.add('anim'); st.style.transform='translate3d(0,'+(-cellH*cur)+'px,0)'; } }
        prev=str.split('').map(Number);
      }
      function frame(now){ const t=(now-start)/1000; currentThousands=(BPS*t)/1000; const stepped=Math.floor(currentThousands*10)/10; setNumber(stepped); requestAnimationFrame(frame); }
      requestAnimationFrame(frame);
    })();

    // Reveal
    const reveals = document.querySelectorAll('.reveal');
    const io = new IntersectionObserver((entries)=>{ entries.forEach(e=>{ if(e.isIntersecting) e.target.classList.add('visible'); }); },{threshold:.2});
    reveals.forEach(el=>io.observe(el));

    // === Canvas сцена: направление = походка, пьёт правой рукой, штаны шире, без артефактов ===
    (function () {
      const cvs = document.getElementById("scene"); if (!cvs) return;
      const ctx = cvs.getContext("2d");
      let dpr = Math.max(1, window.devicePixelRatio || 1);
      function resize(){ const r=cvs.getBoundingClientRect(); cvs.width=Math.max(2,Math.floor(r.width*dpr)); cvs.height=Math.max(2,Math.floor(r.height*dpr)); ctx.setTransform(dpr,0,0,dpr,0,0); }
      resize(); addEventListener("resize", resize);

      // utils
      const TAU=Math.PI*2, clamp=(v,a,b)=>Math.max(a,Math.min(b,v)), mix=(a,b,t)=>a+(b-a)*t, rand=(a,b)=>a+Math.random()*(b-a);
      const easeInOut=(t)=> t<0.5? 2*t*t : 1-(((-2*t+2)**2)/2);
      const easeOutCubic=(t)=>1-(1-t)**3;

      // бутылка
      const cs=()=>getComputedStyle(document.documentElement);
      const drawBottle=(x,y,rot=0,scale=1,alpha=1)=>{
        ctx.save(); ctx.translate(x,y); ctx.rotate(rot); ctx.scale(scale,scale); ctx.globalAlpha=alpha;
        ctx.fillStyle="rgba(0,0,0,0.12)"; ctx.beginPath(); ctx.ellipse(0,32,18,6,0,0,TAU); ctx.fill();
        ctx.fillStyle=cs().getPropertyValue('--bottle').trim()||'#2b8cff';
        ctx.strokeStyle=cs().getPropertyValue('--bottle-stroke').trim()||'#1a58cc';
        ctx.lineWidth=1.2;
        const bw=26,bh=64,r=10;
        ctx.beginPath();
        ctx.moveTo(-bw/2+r,-bh/2); ctx.lineTo(bw/2-r,-bh/2);
        ctx.quadraticCurveTo(bw/2,-bh/2,bw/2,-bh/2+r);
        ctx.lineTo(bw/2,bh/2-r); ctx.quadraticCurveTo(bw/2,bh/2,bw/2-r,bh/2);
        ctx.lineTo(-bw/2+r,bh/2); ctx.quadraticCurveTo(-bw/2,bh/2,-bw/2,bh/2-r);
        ctx.lineTo(-bw/2,-bh/2+r); ctx.quadraticCurveTo(-bw/2,-bh/2,-bw/2+r,-bh/2);
        ctx.closePath(); ctx.fill(); ctx.stroke();
        ctx.fillStyle=cs().getPropertyValue('--bottle-cap').trim()||'#1047a8'; ctx.fillRect(-8,-bh/2-8,16,10);
        ctx.restore();
      };

      // состояние бутылки и мусора
      const bottle={active:false,x:0,y:0,vx:0,vy:0,rot:0,rotVel:0};
      const TRASH_LIMIT=120, trash=[]; // {x,y,rot,scale,alpha,fading}
      function addTrash(x,y,rot,scale){ trash.push({x,y,rot,scale,alpha:1,fading:false}); while(trash.length>TRASH_LIMIT){ const o=trash[0]; o.fading=true; if(o.alpha<=0){ trash.shift(); } else break; } }
      function drawTrash(){ for(let i=0;i<trash.length;i++){ const t=trash[i]; if(t.fading){ t.alpha-=0.01; if(t.alpha<=0){ trash.splice(i,1); i--; continue; } } drawBottle(t.x,t.y,t.rot,t.scale,t.alpha);} }

      // силуэт
      class Actor{
        constructor(){ this.h=520; this.w=this.h*0.30;
          this.angles={ hipL:0,hipR:0,kneeL:0,kneeR:0, ankleL:0,ankleR:0, armL:0,armR:0,elbowL:0,elbowR:0, head:0, bodyTilt:0, shoulderTilt:0, pelvisTilt:0 };
          this._headLag=0;
          this.handRScreen={x:0,y:0}; // экранные координаты правой кисти
        }
        draw(ctx,x,yBase,scale=1,faceLeft=false){
          const H=this.h*scale, W=this.w*scale;
          const yHip=yBase-H*0.58, yShoulder=yBase-H*0.81, yNeck=yBase-H*0.85;

          ctx.save();
          if(faceLeft){ ctx.translate(x+W,0); ctx.scale(-1,1); x=0; } // только зеркалим
          const cx=x+W*0.50;

          // тень
          ctx.fillStyle="rgba(0,0,0,0.12)";
          ctx.beginPath(); ctx.ellipse(cx,yBase-6,90*scale,12*scale,0,0,TAU); ctx.fill();

          // таз (штаны верх)
          ctx.save(); ctx.translate(cx,yHip); ctx.rotate(this.angles.pelvisTilt);
          ctx.fillStyle=cs().getPropertyValue('--pants').trim()||'#0e2140';
          ctx.beginPath(); ctx.ellipse(0,0,W*0.20,H*0.045,0,0,TAU); ctx.fill(); /* шире */
          ctx.restore();

          // торс (футболка — аккуратный контур без артефактов)
          ctx.save(); ctx.translate(cx,(yHip+yShoulder)/2); ctx.rotate(this.angles.bodyTilt);
          const grad=ctx.createLinearGradient(0,yHip-(yHip+yShoulder)/2,0,yShoulder-(yHip+yShoulder)/2);
          grad.addColorStop(0,cs().getPropertyValue('--shirt-top').trim()||'#2657b8');
          grad.addColorStop(1,cs().getPropertyValue('--shirt-bot').trim()||'#1e3a6f');
          ctx.fillStyle=grad;
          ctx.beginPath();
          ctx.moveTo(-W*0.18,(yHip-(yHip+yShoulder)/2));
          ctx.quadraticCurveTo(-W*0.20,(yShoulder-(yHip+yShoulder)/2),-W*0.06,(yNeck-(yHip+yShoulder)/2));
          ctx.lineTo(W*0.06,(yNeck-(yHip+yShoulder)/2));
          ctx.quadraticCurveTo(W*0.20,(yShoulder-(yHip+yShoulder)/2),W*0.18,(yHip-(yHip+yShoulder)/2));
          ctx.closePath(); ctx.fill();
          ctx.restore();

          // шея+голова
          const skin=cs().getPropertyValue('--skin').trim()||'#0b1e33';
          ctx.fillStyle=skin;
          this._headLag = this._headLag*0.88 + this.angles.head*0.12;
          ctx.save(); ctx.translate(cx,yNeck); ctx.rotate(this._headLag);
          ctx.fillRect(-W*0.03,-H*0.015,W*0.06,H*0.03);
          ctx.beginPath(); ctx.ellipse(0,-H*0.045,W*0.11,W*0.14,0,0,TAU); ctx.fill();
          ctx.restore();

          // ноги (штанины шире)
          const drawLeg=(side,hipA,kneeFlex,ankleA)=>{
            const dir=side==='L'?-1:1; const hipX=cx+dir*W*0.12;
            const kneeX=hipX+Math.sin(hipA)*W*0.26, kneeY=yHip+Math.cos(hipA)*H*0.26;
            const shinA=hipA+kneeFlex;
            const ankleX=kneeX+Math.sin(shinA)*W*0.27, ankleY=kneeY+Math.cos(shinA)*H*0.27;

            const pants=cs().getPropertyValue('--pants').trim()||'#0e2140';
            ctx.fillStyle=pants;
            // бедро (шире)
            ctx.beginPath(); ctx.moveTo(hipX-dir*W*0.06,yHip); ctx.lineTo(kneeX-dir*W*0.04,kneeY); ctx.lineTo(kneeX+dir*W*0.04,kneeY); ctx.lineTo(hipX+dir*W*0.06,yHip); ctx.closePath(); ctx.fill();
            // голень (шире)
            ctx.beginPath(); ctx.moveTo(kneeX-dir*W*0.04,kneeY); ctx.lineTo(ankleX-dir*W*0.035,ankleY); ctx.lineTo(ankleX+dir*W*0.035,ankleY); ctx.lineTo(kneeX+dir*W*0.04,kneeY); ctx.closePath(); ctx.fill();
            // стопа
            ctx.save(); ctx.translate(ankleX,ankleY); ctx.rotate(ankleA);
            ctx.beginPath();
            ctx.moveTo(-W*0.08,0); ctx.lineTo(W*0.09,0);
            ctx.quadraticCurveTo(W*0.11,H*0.012,W*0.06,H*0.018);
            ctx.lineTo(-W*0.10,H*0.018);
            ctx.quadraticCurveTo(-W*0.12,H*0.010,-W*0.08,0);
            ctx.closePath(); ctx.fill();
            ctx.restore();
          };
          drawLeg("L", this.angles.hipL, this.angles.kneeL, this.angles.ankleL);
          drawLeg("R", this.angles.hipR, this.angles.kneeR, this.angles.ankleR);

          // руки (короткий рукав уже частью торса; рисуем только «кожу» без лишних треугольников)
          const drawArm=(side,shoulderA,elbowFlex)=>{
            const dir=side==='L'?-1:1; const shX=cx+dir*W*0.12, shY=yShoulder;
            const shoulderRot=shoulderA+this.angles.shoulderTilt*dir*0.3;
            const elbowX=shX+Math.sin(shoulderRot)*W*0.26, elbowY=shY+Math.cos(shoulderRot)*H*0.22;
            const foreRot=shoulderRot+elbowFlex; const handX=elbowX+Math.sin(foreRot)*W*0.24, handY=elbowY+Math.cos(foreRot)*H*0.24;
            ctx.fillStyle=skin;
            ctx.beginPath(); ctx.moveTo(shX-dir*W*0.02,shY+H*0.02); ctx.lineTo(elbowX-dir*W*0.02,elbowY); ctx.lineTo(elbowX+dir*W*0.02,elbowY); ctx.lineTo(shX+dir*W*0.02,shY+H*0.02); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.moveTo(elbowX-dir*W*0.02,elbowY); ctx.lineTo(handX-dir*W*0.02,handY); ctx.lineTo(handX+dir*W*0.02,handY); ctx.lineTo(elbowX+dir*W*0.02,elbowY); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.ellipse(handX,handY,W*0.018,W*0.018,0,0,TAU); ctx.fill();
            return {handX,handY};
          };
          // правая рука — важна для бутылки
          const hr = drawArm("R", this.angles.armR, this.angles.elbowR);
          this.handRScreen = {x:hr.handX, y:hr.handY};
          drawArm("L", this.angles.armL, this.angles.elbowL);

          ctx.restore();
        }
      }

      const actor=new Actor();

      // цикл
      let playing=false,startT=0,cycle=0,goRight=true;
      let hasBottleInHand=true, releasedThisCycle=false;

      function startCycle(){
        goRight=(cycle%2===0); cycle++;
        hasBottleInHand=true; releasedThisCycle=false;
        Object.assign(bottle,{active:false,x:0,y:0,vx:0,vy:0,rot:0,rotVel:0});
        startT=performance.now(); playing=true; requestAnimationFrame(draw);
      }
      function stop(){ playing=false; }

      function draw(now){
        const w=cvs.clientWidth||cvs.width/dpr, h=cvs.clientHeight||cvs.height/dpr, yBase=h*0.95;
        ctx.clearRect(0,0,w,h);
        // пол
        const g=ctx.createLinearGradient(0,yBase-80,0,yBase+20); g.addColorStop(0,"rgba(10,31,51,0.03)"); g.addColorStop(1,"rgba(10,31,51,0)");
        ctx.fillStyle=g; ctx.fillRect(0,yBase-80,w,100);
        // мусор
        drawTrash();

        const T=8, t=clamp((now-startT)/1000,0,T);

        // движение по X
        const xEnter=goRight?-0.2*w:1.2*w, xMid=goRight?mix(-0.2*w,1.2*w,0.35):mix(1.2*w,-0.2*w,0.35), xExit=goRight?1.2*w:-0.2*w;
        let x; if(t<2) x=mix(xEnter,xMid,easeOutCubic(t/2)); else if(t<5) x=xMid; else x=mix(xMid,xExit,(t-5)/3);

        // ФАЗЫ ШАГА — одинаковые для обоих направлений (визуально зеркалим)
        const scale=clamp(h/actor.h*0.9,0.55,1);
        const stepPhase=t*TAU*0.75;
        const yMan=yBase-actor.h*scale + Math.sin(stepPhase)*5.0;

        // бедро/колено/щиколотка
        actor.angles.hipL =  Math.sin(stepPhase)*0.25;
        actor.angles.hipR = -actor.angles.hipL;

        const kneeFlex=(phi)=> Math.max(0,Math.sin(phi+Math.PI/2))*0.9 + 0.5;
        actor.angles.kneeL = kneeFlex(stepPhase+Math.PI);
        actor.angles.kneeR = kneeFlex(stepPhase);

        const tri=(v)=> (v<0.5? v*2 : 1-(v-0.5)*2);
        const ankleLPhase = tri((Math.sin(stepPhase)+1)/2);
        const ankleRPhase = tri((Math.sin(stepPhase+Math.PI)+1)/2);
        actor.angles.ankleL = -0.12 + 0.24*ankleLPhase;
        actor.angles.ankleR = -0.12 + 0.24*ankleRPhase;

        // корпус/плечи/голова
        actor.angles.pelvisTilt   = Math.sin(stepPhase)*0.05;
        actor.angles.bodyTilt     = Math.sin(stepPhase+Math.PI)*0.045;
        actor.angles.shoulderTilt = Math.sin(stepPhase+Math.PI)*0.06;

        // левая рука противофазно походке
        actor.angles.armL   = -actor.angles.hipL * 0.55;
        actor.angles.elbowL =  actor.angles.armL + 0.85;

        // правая рука: тянем к рту (пьёт) и опускаем обратно
        if(t<2.2){
          actor.angles.armR=0.2; actor.angles.elbowR=1.0; actor.angles.head=0;
        } else if(t<3.4){
          const k=easeInOut((t-2.2)/1.2);
          actor.angles.armR = mix(0.2, -1.05, k);   // плечо кверху/вперёд
          actor.angles.elbowR = mix(1.0, 1.85, k);  // сгиб локтя
          actor.angles.head = mix(0, -0.22, k);     // лёгкий наклон головы
        } else if(t<4.2){
          const k=(t-3.4)/0.8;
          actor.angles.armR = -1.05 + Math.sin(k*TAU)*0.04;
          actor.angles.elbowR = 1.85 + Math.sin(k*TAU)*0.03;
          actor.angles.head = -0.22;
        } else if(t<5){
          const k=easeOutCubic((t-4.2)/0.8);
          actor.angles.armR = mix(-1.05, 0.25, k);
          actor.angles.elbowR = mix(1.85, 0.9, k);
          actor.angles.head = mix(-0.22, 0, k);

          // отпускаем ОДИН раз
          if(!releasedThisCycle){
            hasBottleInHand=false; releasedThisCycle=true;
            Object.assign(bottle,{
              active:true,
              x: actor.handRScreen.x,
              y: actor.handRScreen.y,
              vx: (goRight? 90 : -90) * 0.6,
              vy: -120,
              rot: -0.25*(goRight?1:-1),
              rotVel: (goRight?1:-1)*2.0
            });
          }
        } else {
          actor.angles.armR=0.25; actor.angles.elbowR=0.9; actor.angles.head=0;
        }

        // отрисовка силуэта (зеркалим по направлению: направо — лицом вправо; налево — влево)
        actor.draw(ctx, x, yBase, scale, !goRight);

        // бутылка: либо в руке, либо летит
        if(hasBottleInHand){
          drawBottle(actor.handRScreen.x, actor.handRScreen.y, -0.10*(goRight?1:-1), 1, 1);
        } else if(bottle.active){
          const dt=1/60;
          bottle.vy+=1400*dt; bottle.x+=bottle.vx*dt; bottle.y+=bottle.vy*dt; bottle.rot+=bottle.rotVel*dt;
          if(bottle.y>yBase-14){
            bottle.y=yBase-14;
            addTrash(bottle.x+rand(-6,6), bottle.y, bottle.rot+rand(-0.1,0.1), 0.9+Math.random()*0.2);
            bottle.active=false;
          } else {
            drawBottle(bottle.x,bottle.y,bottle.rot,1,1);
          }
        }

        if(t<T && playing){ requestAnimationFrame(draw); }
        else if(t>=T && playing && !bottle.active){ playing=false; }
      }

      // запуск по видимости
      const sec=document.querySelector(".why");
      const ioScene=new IntersectionObserver((ents)=>{ ents.forEach(e=>{ if(e.isIntersecting){ if(!playing) startCycle(); } else { stop(); } }); },{threshold:.35});
      ioScene.observe(sec);
    })();
  </script>
</body>
</html>
